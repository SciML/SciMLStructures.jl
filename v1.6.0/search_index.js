var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SciMLStructures]","category":"page"},{"location":"api/#SciMLStructures.AbstractPortion","page":"API","title":"SciMLStructures.AbstractPortion","text":"An AbstractPortion object to be used in the SciMLStructures.jl interfaces, i.e. canonicalize(::AbstractPortion, p::T1) or replace!(::AbstractPortion, p::T1).\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLStructures.Caches","page":"API","title":"SciMLStructures.Caches","text":"The caches portion of the SciMLStructure, i.e. the caches which are meant to allow for writing the model function without allocations.\n\nRules for caches:\n\nCaches should be a mutable object.\nCaches should not assume any previous value in them. All values within the cache should be written into in the f cal that it is used from.\n\nFor making caches compatible with automatic differentiation, see PreallocationTools.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLStructures.Constants","page":"API","title":"SciMLStructures.Constants","text":"The constant portion of the SciMLStructure, i.e. the parameters which are meant to be constant with respect to optimization.\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLStructures.Discrete","page":"API","title":"SciMLStructures.Discrete","text":"The discrete portion of the SciMLStructure.\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLStructures.Input","page":"API","title":"SciMLStructures.Input","text":"The inputs portion of the SciMLStructure.\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLStructures.Tunable","page":"API","title":"SciMLStructures.Tunable","text":"The tunable portion of the SciMLStructure, i.e. the parameters which are meant to be optimized.\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLStructures.canonicalize","page":"API","title":"SciMLStructures.canonicalize","text":"canonicalize(::AbstractPortion, p::T1) -> values::T2, repack, aliases::Bool\n\nThe core function of the interface is the canonicalize function. canonicalize allows the user to define to the solver how to represent the given \"portion\" in a standard AbstractVector type which allows for interfacing with standard tools like linear algebra in an efficient manner. The type of portions which are defined are:\n\nTunable: the tunable values/parameters, i.e. the values of the structure which are supposed to be considered non-constant when used in the context of an inverse problem solve. For example, this is the set of parameters to be optimized during a parameter estimation of an ODE.\nTunable parameters are expected to return an AbstractVector of unitless values.\nTunable parameters are expected to be constant during the solution of the ODE.\nConstants: the values which are to be considered constant by the solver, i.e. values which are not estimated in an inverse problem and which are unchanged in any operation by the user as part of the solver's usage.\nCaches: the stored cache values of the struct, i.e. the values of the structure which are used as intermediates within other computations in order to avoid extra allocations.\nDiscrete: the discrete portions of the state captured inside of the structure. For example, discrete values stored outside of the u in the parameters to be modified in the callbacks of an ODE.\nAny parameter that is modified inside of callbacks should be considered Discrete.\n\nDefinitions for Base Objects\n\nVector: returns an aliased version of itself as Tunable, and an empty vector matching type for Constants, Caches, and Discrete.\nArray: returns the vec(p) aliased version of itself as Tunable, and an empty vector matching type for Constants, Caches, and Discrete.\n\n\n\n\n\n","category":"function"},{"location":"api/#SciMLStructures.hasportion","page":"API","title":"SciMLStructures.hasportion","text":"hasportion(::AbstractPortion, p)::Bool\n\nDenotes whether a portion is used in a given definition of a SciMLStructure. If false, then it's expected that the canonical values are nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#SciMLStructures.ismutablescimlstructure","page":"API","title":"SciMLStructures.ismutablescimlstructure","text":"Returns whether the SciMLStructure object is mutable and thus compatible with the interface functions that require mutation. Note that this is not mutable in the sense of the Julia type, rather mutable in the sense of AbstractPortion replacement, i.e. replace!\n\n\n\n\n\n","category":"function"},{"location":"api/#SciMLStructures.isscimlstructure-Tuple{Any}","page":"API","title":"SciMLStructures.isscimlstructure","text":"Returns whether the object satisfies the SciMLStructure interface. Defaults to false and types are required to opt-into the interface.\n\n\n\n\n\n","category":"method"},{"location":"api/#SciMLStructures.replace","page":"API","title":"SciMLStructures.replace","text":"replace(::AbstractPortion, p::T1, new_values) -> p::T1\n\nEquivalent to canonicalize(::AbstractPortion, p::T1)[2](new_values), though allowed to optimize and not construct intermediates. For more information on the arguments, see canonicalize.\n\n\n\n\n\n","category":"function"},{"location":"api/#SciMLStructures.replace!","page":"API","title":"SciMLStructures.replace!","text":"replace!(::AbstractPortion, p::T1, new_values)::Nothing\n\nEquivalent to canonicalize(::AbstractPortion, p::T1)[2](new_values), though done in a mutating fashion and is allowed to optimize and not construct intermediates. Requires a mutable SciMLStructure. For more information on the arguments, see canonicalize.\n\n\n\n\n\n","category":"function"},{"location":"interface/#The-SciMLStructure-Interface","page":"The SciMLStructure Interface","title":"The SciMLStructure Interface","text":"","category":"section"},{"location":"interface/#Core-Interface-Definitions","page":"The SciMLStructure Interface","title":"Core Interface Definitions","text":"","category":"section"},{"location":"interface/#isscimlstructure-Definition","page":"The SciMLStructure Interface","title":"isscimlstructure Definition","text":"","category":"section"},{"location":"interface/","page":"The SciMLStructure Interface","title":"The SciMLStructure Interface","text":"isscimlstructure(p)::Bool\nismutablescimlstructure(p)::Bool","category":"page"},{"location":"interface/","page":"The SciMLStructure Interface","title":"The SciMLStructure Interface","text":"Returns whether the object satisfies the SciMLStructure interface. Defaults to false and types are required to opt-into the interface.","category":"page"},{"location":"interface/#canonicalize-Definition","page":"The SciMLStructure Interface","title":"canonicalize Definition","text":"","category":"section"},{"location":"interface/","page":"The SciMLStructure Interface","title":"The SciMLStructure Interface","text":"canonicalize(::AbstractPortion, p::T1) -> values::T2, repack, aliases::Bool\nrepack(new_values::T2) -> p::T1 # with values replaced with new_values\nreplace(::AbstractPortion, p::T1, new_values) -> p::T1\nreplace!(::AbstractPortion, p::T1, new_values)::Nothing # Requires mutable","category":"page"},{"location":"interface/#Portion-Definitions","page":"The SciMLStructure Interface","title":"Portion Definitions","text":"","category":"section"},{"location":"interface/","page":"The SciMLStructure Interface","title":"The SciMLStructure Interface","text":"The core function of the interface is the canonicalize function. canonicalize allows the user to define to the solver how to represent the given \"portion\" in a standard AbstractVector type which allows for interfacing with standard tools like linear algebra in an efficient manner. The type of portions which are defined are:","category":"page"},{"location":"interface/","page":"The SciMLStructure Interface","title":"The SciMLStructure Interface","text":"Tunable: the tunable values/parameters, i.e. the values of the structure which are supposed to be considered non-constant when used in the context of an inverse problem solve. For example, this is the set of parameters to be optimized during a parameter estimation of an ODE.\nTunable parameters are expected to return an AbstractVector of unitless values.\nTunable parameters are expected to be constant during the solution of the ODE.\nConstants: the values which are to be considered constant by the solver, i.e. values which are not estimated in an inverse problem and which are unchanged in any operation by the user as part of the solver's usage.\nCaches: the stored cache values of the struct, i.e. the values of the structure which are used as intermediates within other computations in order to avoid extra allocations.\nDiscrete: the discrete portions of the state captured inside of the structure. For example, discrete values stored outside of the u in the parameters to be modified in the callbacks of an ODE.\nAny parameter that is modified inside of callbacks should be considered Discrete.","category":"page"},{"location":"interface/#Definitions-for-Base-Objects","page":"The SciMLStructure Interface","title":"Definitions for Base Objects","text":"","category":"section"},{"location":"interface/","page":"The SciMLStructure Interface","title":"The SciMLStructure Interface","text":"Vector: returns an aliased version of itself as Tunable, and an empty vector matching type for Constants, Caches, and Discrete.\nArray: returns the vec(p) aliased version of itself as Tunable, and an empty vector matching type for Constants, Caches, and Discrete.","category":"page"},{"location":"#SciMLStructures.jl:-Structured-Objects-for-Non-State-Values-in-System-Solvers","page":"Home","title":"SciMLStructures.jl: Structured Objects for Non-State Values in System Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SciMLStructures.jl defines a generic interface for interacting with solvers, estimation tooling, and more within the SciML ecosystem and the greater Julia universe. SciMLStructures.jl defines a structured enforceable interface which allows for solvers to be able to handle custom user types in an efficient and generalized way.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SciMLStructures.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SciMLStructures\")","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"example/#An-example-implementation-of-the-interface","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"","category":"section"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"In this tutorial we will implement the SciMLStructures.jl interface for a parameter object. This is useful when differentiating through ODE solves using SciMLSensitivity.jl and only part of the parameters are differentiable.","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"using OrdinaryDiffEqTsit5\nusing LinearAlgebra\n\nmutable struct SubproblemParameters{P, Q, R}\n  p::P # tunable\n  q::Q\n  r::R\nend\n\nmutable struct Parameters{P, C}\n  subparams::P\n  coeffs::C # tunable matrix\nend\n\n# the rhs is `du[i] = p[i] * u[i]^2 + q[i] * u[i] + r[i] * t` for i in 1:length(subparams)\n# and `du[length(subparams)+1:end] .= coeffs * u`\nfunction rhs!(du, u, p::Parameters, t)\n  for (i, subpars) in enumerate(p.subparams)\n    du[i] = subpars.p * u[i]^2 + subpars.q * u[i] + subpars.r * t\n  end\n  N = length(p.subparams)\n  mul!(view(du, (N+1):(length(du))), p.coeffs, u)\n  return nothing\nend\n\nu = sin.(0.1:0.1:1.0)\nsubparams = [SubproblemParameters(0.1i, 0.2i, 0.3i) for i in 1:5]\np = Parameters(subparams, cos.([0.1i+0.33j for i in 1:5, j in 1:10]))\ntspan = (0.0, 1.0)\n\nprob = ODEProblem(rhs!, u, tspan, p)\nsolve(prob, Tsit5())","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"The ODE solves fine. Now let's try to differentiate with respect to the tunable parameters.","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"using Zygote\nusing SciMLSensitivity\n\n# 5 subparams[i].p, 50 elements in coeffs\nfunction simulate_with_tunables(tunables)\n  subpars = [SubproblemParameters(tunables[i], subpar.q, subpar.r) for (i, subpar) in enumerate(p.subparams)]\n  coeffs = reshape(tunables[6:end], size(p.coeffs))\n  newp = Parameters(subpars, coeffs)\n  newprob = remake(prob; p = newp)\n  sol = solve(prob, Tsit5())\n  return sum(sol.u[end])\nend","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"SciMLSensitivity does not know how to handle the parameter object, because it does not implement the SciMLStructures interface. The bare minimum necessary for SciMLSensitivity is the Tunable portion.","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"import SciMLStructures as SS\n\n# Mark the struct as a SciMLStructure\nSS.isscimlstructure(::Parameters) = true\n# It is mutable\nSS.ismutablescimlstructure(::Parameters) = true\n\n# Only contains `Tunable` portion\n# We could also add a `Constants` portion to contain the values that are\n# not tunable. The implementation would be similar to this one.\nSS.hasportion(::SS.Tunable, ::Parameters) = true\n\nfunction SS.canonicalize(::SS.Tunable, p::Parameters)\n  # concatenate all tunable values into a single vector\n  buffer = vcat([subpar.p for subpar in p.subparams], vec(p.coeffs))\n\n  # repack takes a new vector of the same length as `buffer`, and constructs\n  # a new `Parameters` object using the values from the new vector for tunables\n  # and retaining old values for other parameters. This is exactly what replace does,\n  # so we can use that instead.\n  repack = let p = p\n    function repack(newbuffer)\n      SS.replace(SS.Tunable(), p, newbuffer)\n    end\n  end\n  # the canonicalized vector, the repack function, and a boolean indicating\n  # whether the buffer aliases values in the parameter object (here, it doesn't)\n  return buffer, repack, false\nend\n\nfunction SS.replace(::SS.Tunable, p::Parameters, newbuffer)\n  N = length(p.subparams) + length(p.coeffs)\n  @assert length(newbuffer) == N\n  subparams = [SubproblemParameters(newbuffer[i], subpar.q, subpar.r) for (i, subpar) in enumerate(p.subparams)]\n  coeffs = reshape(view(newbuffer, (length(p.subparams)+1):length(newbuffer)), size(p.coeffs))\n  return Parameters(subparams, coeffs)\nend\n\nfunction SS.replace!(::SS.Tunable, p::Parameters, newbuffer)\n  N = length(p.subparams) + length(p.coeffs)\n  @assert length(newbuffer) == N\n  for (subpar, val) in zip(p.subparams, newbuffer)\n    subpar.p = val\n  end\n  copyto!(coeffs, view(newbuffer, (length(p.subparams)+1):length(newbuffer)))\n  return p\nend","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"Now, we should be able to differentiate through the ODE solve.","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"Zygote.gradient(simulate_with_tunables, 0.1ones(length(SS.canonicalize(SS.Tunable(), p)[1])))","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"We can also implement a Constants portion to store the rest of the values:","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"SS.hasportion(::SS.Constants, ::Parameters) = true\n\nfunction SS.canonicalize(::SS.Constants, p::Parameters)\n  buffer = mapreduce(vcat, p.subparams) do subpar\n    [subpar.q, subpar.r]\n  end\n  repack = let p = p\n    function repack(newbuffer)\n      SS.replace(SS.Constants(), p, newbuffer)\n    end\n  end\n\n  return buffer, repack, false\nend\n\nfunction SS.replace(::SS.Constants, p::Parameters, newbuffer)\n  subpars = [SubproblemParameters(p.subparams[i].p, newbuffer[2i-1], newbuffer[2i]) for i in eachindex(p.subparams)]\n  return Parameters(subpars, p.coeffs)\nend\n\nfunction SS.replace!(::SS.Constants, p::Parameters, newbuffer)\n  for i in eachindex(p.subparams)\n    p.subparams[i].q = newbuffer[2i-1]\n    p.subparams[i].r = newbuffer[2i]\n  end\n  return p\nend\n\nbuf, repack, alias = SS.canonicalize(SS.Constants(), p)\nbuf","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"repack(ones(length(buf)))","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"SS.replace(SS.Constants(), p, ones(length(buf)))","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"SS.replace!(SS.Constants(), p, ones(length(buf)))\np","category":"page"},{"location":"example/","page":"An example implementation of the interface","title":"An example implementation of the interface","text":"In general, all values belonging to a portion should be concatenated into an array of the appropriate length in canonicalize. If a higher dimensional array is part of the portion, it should be flattened. If a portion contains values of multiple types, a non-concrete array should be used to store the values. replace and replace! should assume the array they receive have the same ordering as the one returned from canonicalize.","category":"page"}]
}
